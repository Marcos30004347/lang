// NOTE(marcos): language does not have type inference yet
// for things to work all typing information needs to be
// statically available.


f : any : (x:i32) -> i32 {
	return 0;
}

iter : any : (x:i32, p: i32*i32 -> i32, f: i32 -> i32) -> i32 {
	h : i32*i32 -> i32 : (a:i32, r:i32) -> i32 {
		z : i32 : p(a, r);

		if z {
			return a;
		} else {
			u : i32 : f(a);
			y : i32 : h(u, a);
			return y;
		}
	}

	t : i32 : h(x, 1);

	return t;
}

g :: () {
	x := 0;
	y := 0;
	z := 0;

	mul :: () {
		x = x + 1;
		z = z + 1;
		y = y + 1;
	}

	add :: () {
		x = x + 1;
		z = z + 1;
	}

	sub :: () {
		x = x + 1;
		y = y + 1;
	}

	mul();
	add();

	return add, sub, mul;
}


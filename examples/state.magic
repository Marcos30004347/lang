get: effect unit * (resume i32 -> i32 -> i32) -> i32;

set: effect i32 * (resume unit -> i32 -> i32) -> unit;

fun :: (f: i32 * i32 * i32 -> i32) -> i32 | alloc! {
	a : i32 : alloc!(i32, 3);
	b : i32 : alloc!(i32, 4);
	c : i32 : alloc!(i32, 5);

	return f(a, b, c);
}

state :: handler {
	get :: (u: unit, f: resume i32 -> i32 -> i32) -> i32 -> i32 {
		return (s: i32) {
			return f(s)(s);
		}
	}

	set :: (s: i32, f: resume unit -> i32 -> i32) -> unit -> i32 {
		return () {
			return f()(s);
		}
	}
}

f :: () -> i32 | set! | get! {
	set!(3);

	x :: get!();

	set!(4);

	y :: get!();

	return x + y;
}

main :: () -> i32 {
	g :: f() with state;
	x :: g(0);

	return x;
}

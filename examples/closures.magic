// NOTE(marcos): language does not have type inference yet
// for things to work all typing information needs to be
// statically available.

f :: (x:i32) -> i32 {
	return 0;
}

iter :: (x:i32, p: i32*i32 -> i32, f: i32 -> i32) -> i32 {
	h : i32*i32 -> i32 : (a:i32, r:i32) -> i32 {
		z : i32 : p(a, r);

		if z {
			return a;
		} else {
			u : i32 : f(a);
			y : i32 : h(u, a);
			i : i32 : y + 4;
			return i;
		}
	}

	t : i32 : h(x, 1);

	return t;
}

